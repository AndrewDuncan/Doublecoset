\documentclass[a4paper,12pt]{article}
\usepackage{amsmath,amsfonts,amsthm,amscd,amssymb,latexsym}%,eufrak}
%%%%%%%%%%%%%
\usepackage{caption}
\usepackage{subcaption}
\usepackage{enumerate,graphicx,psfrag}%,subfigure}%,jchangebar,oldgerm}
\usepackage[mathscr]{eucal}
\usepackage[usenames]{color}
\usepackage{url}
\usepackage[shortlabels]{enumitem}
\usepackage{comment}
%\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{showkeys}
%%%%%%%%%
\sloppy

%%\documentclass[12]{article}


%%%%%%%%%%%%%%%%%%%%%%%
%
%
%
\title{The subgroup membership problem
}
\author{Andrew J. Duncan, Elizaveta Frenkel}

\renewcommand{\a}{\alpha }
\renewcommand{\b}{\beta }
\newcommand{\G}{\Gamma }
\newcommand{\g}{\gamma }
\newcommand{\D}{\Delta }
\renewcommand{\d}{\delta }
%\def\vd{\vardelta}
\newcommand{\ep}{\epsilon }
\newcommand{\e}{\varepsilon }
\newcommand{\z}{\zeta }
%\eta
\renewcommand{\th}{\theta }
\newcommand{\T}{\Theta }
\renewcommand{\i}{\iota }
\renewcommand{\k}{\kappa }
\renewcommand{\l}{\lambda }
\renewcommand{\L}{\Lambda }
%\mu
%\nu
%\xi
%omicron
%\pi
\renewcommand{\r}{\rho }
\newcommand{\s}{\sigma }
\renewcommand{\S}{\Sigma }
\renewcommand{\t}{\tau }
\newcommand{\up}{\upsilon }
\newcommand{\U}{\Upsilon }
%\phi
\newcommand{\x}{\chi }
%\psi
\newcommand{\W}{\Omega }
\newcommand{\w}{\omega }
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\pd}{\partial}
\newcommand{\wht}{\widehat}
%\newcommand{\cC}{{\mathcal C}}
%\newcommand{\cdim}{\texttt{cdim}}
\newcommand{\fC}{{\textswab C}}
\newenvironment{ef}{\noindent\color{blue} \bf EF: }{}
%
\newcommand{\cA}{{\cal{A}}}
\newcommand{\cD}{{\cal{D}}}
\newcommand{\cF}{{\cal{F}}}
\newcommand{\cH}{{\cal{H}}}
\newcommand{\cJ}{{\cal{J}}}

\newcommand{\cK}{{\cal{K}}}
\newcommand{\cP}{{\cal{P}}}
\newcommand{\cR}{{\cal{R}}}
\newcommand{\cS}{{\cal{S}}}
\newcommand{\cW}{{\cal{W}}}
\newcommand{\cQ}{{\cal{Q}}}
%\newcommand{\GG}{\ensuremath{\mathbb{G}}}
\newcommand{\pp}{\mathbf{p}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\nul}{\emptyset }

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{axiom}[theorem]{Axiom}
\newtheorem{definition}[theorem]{Definition}
\newtheorem*{defn*}{Definition}
\newtheorem{conjecture}[theorem]{Conjecture}
%cvs -d :pserver:najd2@cvs.mas.ncl.ac.uk:/CVS/najd2
\newtheorem{exam}[theorem]{Example}
%\newtheorem{comment}[theorem]{Comment}
%
%
\newenvironment{example}{\begin{exam} \rm}{\end{exam}}
%
%
%
\newtheorem{remk}[theorem]{Remark}
\newenvironment{remark}{\begin{remk} \rm}{\end{remk}}
%
%%%%%%%%%%%%
\numberwithin{equation}{section}
\numberwithin{figure}{section}
%%%%%%%%%%%%%%%%%%%%
\newcommand{\Loop}{\operatorname{Loop}}
\newcommand{\Iso}{\operatorname{Isom}}
\newcommand{\Aut}{\operatorname{Aut}}
\newcommand{\vim}{\nu\textrm{-im}}
%%%%%%%%%%%%%%%%%%%
\renewcommand{\AA}{\ensuremath{\mathbb{A}}}
\newcommand{\ZZ}{\ensuremath{\mathbb{Z}}}
\newcommand{\QQ}{\ensuremath{\mathbb{Q}}}
\newcommand{\RR}{\ensuremath{\mathbb{R}}}
\newcommand{\NN}{\ensuremath{\mathbb{N}}}
\newcommand{\CC}{\ensuremath{\mathbb{C}}}
\newcommand{\FF}{\ensuremath{\mathbb{F}}}
%\renewcommand{\ker}{\verb"Ker"}
\newcommand{\cC}{\mathcal{C}}
\renewcommand{\cF}{\mathcal{F}}
\newcommand{\cO}{\mathcal{O}}
\renewcommand{\cS}{\mathcal{S}}
\newcommand{\la}{\langle}
\newcommand{\ra}{\rangle}
%\newcommand{\BA}{\ensuremath{\mathbb{A}}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\maps}{\rightarrow}
\newcommand{\ov}[1]{\overline{#1}}
\newcommand{\bs}{\backslash}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\be}{\begin{enumerate}}
\newcommand{\ee}{\end{enumerate}}
\newcommand{\bd}{\begin{description}}
\newcommand{\ed}{\end{description}}
\newcommand{\biz}{\begin{itemize}}
\newcommand{\eiz}{\end{itemize}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
\newenvironment{ajd}{\noindent\color{red} AJD }{}
\newenvironment{xxx}{\noindent\color{red}}{}
%
\begin{document}
\section{Summary of algorithm I}
\subsection{Preproccessing.}
Given $F_1*_{H_1=H_2} F_2$
 the 
steps in this subsection are carried out once for 
each group $H_i$. Once these steps have been completed
then Algorithm I can be run, as many times as necessary,
to find double coset normal forms.
 
\noindent\textbf{Input.}
\biz
\item generators $X$ of a free group $F(X)$.
\item A finite set $Y$ of elements of $F(X)$.
\eiz
\noindent\textbf{Output.}
\biz
\item 
$\G_A$, the Stallings automaton for the subgroup $H=\la Y\ra$ of $F(X)$.
\item
$L_T$, the set of words corresponding to a  maximal subtree $T$ of $\G_A$.
\item The set $P$ of non-diagonal elements of $V( \G_A\times \G_A)$ 
partitioned into equivalence classes of $\sim$ (i.e. vertices in the
same connected components of $\G_A\times \G_A$).
\item $P_0$ the set of representatives of equivalence classes of 
elements of $P$.
\item $C$ the set of connecting elements, one for each element of $P$.
\eiz
\noindent\textbf{Process.}
An upper bound for each step is given in brackets.
Let $N=\sum{y\in Y} |y|$.
\be
\item Construct $\G_A$. ($t_1(N)$.)
\item Construct a spanning tree $T$ for $\G_A$ and simultaneously
compute $L_T$. (This can easily be done if $T$ is constructed by
BFS or DFS, so one problem I was worrying about disappears.) ($O(N^2)$.)
\item Construct $\G_A\times \G_A$. ($t_3(N,N)$).
\item Find connected components of $\G_A\times \G_A$. This can be
done by doing a BFS or DFS of $\G_A\times \G_A$, which constructs
a spanning forest $F$ at the same time as finding the set $C$ of
connected components,
which can be taken to be paths in the spanning forest $F$. 
($O(N^4)$).
\item Construct the set $P_0$. This can be done easily using $L_T(A)$ and
the forest $F$. ($O(N^2)$).  
\ee
\noindent\textbf{Question.} Is it better for our algorithm
to construct $T$ by BFS or DFS? Does it make any difference to the 
Algorithm II? 

Preprocessing time is bounded above by $O(N^4)$. 
\subsection{Execution of Algorithm I}
\noindent\textbf{Input.}
\biz
\item $w$, a reduced word in $F(X)$.
\eiz
\noindent\textbf{Output.} 
\biz
\item Double coset normal form of $w$. 
\eiz
\noindent\textbf{Process.}
\be
\item Use $\G_A$ to find the maximal prefix $h$ of $w$ accepted. 
Let $w=h\circ f$. 
\item Use $\G_A$ to find the maximal $L_Q$-prefix $p$ of $f$. 
Let $f=p\circ q$.
\item Use $\G_A$ to find the maximal prefix $g$ of $q^{-1}$ accepted.
Let $q=r^{-1}\circ g^{-1}$.
\item Use $\G_A$ to find the maximal $L_Q$-prefix $t$ of $r$. 
Let $r=t\circ e^{-1}$. 
\item If $e=1$ go to step \ref{it:ss}.
\item Using $L_T$, set $y=w(\t(p))$ and $z=w(\t(t))$.
\item Freely reduce $hpy^{-1}$, $yez^{-1}$ and $zt^{-1}g^{-1}$ and 
call the results   $a, b$ and $c$. 
\item Output $a,b,c$ and stop.
\item\label{it:ss} (This step is reached only if $e= 1$.)
 Using $P_0$ and $F$ find the representative $(u_0,v_0)$ of $(\t(p),\t(t))$.
\item Look up the connecting element $c(u,v)$. 
\item Let $y=w(u_0)$ and $z=w(v_0)$. 
\item Freely reduce $hpcy^{-1}$ and $zc^{-1}t^{-1}g^{-1}$ and call the 
results $a$ and $b$.
\item Output $a,yz^{-1},b$.
\ee
The time required for these steps is $O(|w|)$. 

\section{Summary of Algorithm II}
Here we assume $F_1*_{H_1=H_2} F_2$
 where $F_k$ is generated by $X_k$, $H_k$ is generated 
by $Y_k=\{h_{k,1},\ldots, h_{k,m}\}$ 
and the Stallings automata $\G_{A_k}$ for $H_k$ have
been constructed. Let  $\S=(X_1\cup X_2\cup Z)^{\pm 1}$ and, for $k=1,2$,  
assume that we have constructed, at the preprocessing stage, the following. 
\be
\item 
A spanning tree  $T_k$ for $\G_{A_k}$, 
 the set $L_{T_k}$of words corresponding to the  maximal subtree $T_k$, 
the set $P_k$ of non-diagonal elements of 
$V( \G_{A_k}\times \G_{A_k})$,   
 the set of representatives  $P_{k,0}$ of equivalence classes of 
elements of $P_k$ and the
set $C_k$ of connecting elements, one for each element of $P_k$.
%%%%%%%%
\item $\phi_k:Z\maps F_k$ be a map inducing an isomorphism from $F(Z)$ to
$H_k$. This map is encoded as part of $\G_{A_k}$. More precisely, 
edges of $\G_{A_k}$ have two types of label; \emph{input} and \emph{output}.
Labels we discussed above are input labels, are 
referred to simply as \emph{labels}, and are elements of $X_1\cup X_2$. 
Output labels are elements of  $Z\cup \{1\}$.
 Edges of $T_k$  all have output label $1$; and each directed 
edge of $\G_{A_k}$ not in $T_k$ has output 
label an element of $Z$. Each such edge corresponds uniquely to
 an element $h_{k,i}$ of the free generating set for $H_k$, and the edge
corresponding to $h_{k,i}$ has 
 output label  $z_i\in Z$. Moreover, in this case $\phi_k(z_i)=h_{k,i}$.  
  This means that if a word in $H_k$ is given in terms of $Y_k$  then its
image under $\phi_k^{-1}$ can be read off from $\G_{A_k}$ (regarded as a
 transducer), by reading output labels. 
\ee
 
\noindent\textbf{Input.}
\biz
\item An inverse automaton $\D$ with alphabet $\Sigma$ and start 
and final state $1$, such that $\pi(L(\D))=K$. Edges labelled 
with elements of $X_k$ are said to have type $k$. Edges labelled with
elements of $Z$ are said to have type $Z$. 
\item Stallings automata $\G_{A_1}$ and $\G_{A_2}$ for $H_1$ and $H_2$, 
with output labels 
encoding $\phi_1$ and $\phi_2$, as above. 
\item For each $z \in Z$ the images $\phi_1(z)$ and $\phi_2(z)$ of 
as words in $Y_1^{\pm 1}$ and $Y_2^{\pm 1}$, respectively.
\eiz
\noindent\textbf{Output.}
\biz
\item An inverse automaton $\D''$ (with alphabet $\Sigma$ and start 
and final state $1$, such that $\pi(L(\D''))=K$). 
\eiz
\noindent\textbf{Process.}\\
Each of the following steps is executed for $k=1$ and $2$.
\be[{A}1]
\item\label{it:A1} Construct $\D_k$ and the map $\nu$.  In more detail the steps are 
the following. 
\be
\item\label{it:A1a} Remove all edges of type $X_{k'}$, where $k'=1-k$, from $\D$; adding
edges removed to  a graph $\D_Z$ (which starts off empty, when $k=1$, but
is not reinitialised when $k$ is incremented to $2$). 
\item\label{it:A1b} A \emph{shoot} is an edge incident to a leaf. Remove all shoots
of type $Z$ from $\D_k$; adding edges removed to $\D_Z$. Continue
until there are no shoots of type $Z$ in $\D_k$.
\item\label{it:A1c} Rename vertices of $\D_k$: a vertex named $v$ in $\D$ becomes
$(v,k)$ in $\D_k$. 
\item\label{it:A1d} For each vertex $(v,k)$ of $\D_k$ keep a record of the image
of $(v,k)$ in $\D$ (under $\nu$). In practice, for each $(v,k)$ keep
 a record $\vim(v,k)$ which is initially set to $\{v\}$.     
\ee
\item\label{it:A2} (\textbf{Begin Modification 1}.) For all edges 
$(\a,z,\b)$ of $\D_k$, where $z\in Z$, add a path $(\a,\phi_k(z),\b)$ to
$\D_k$. For later reference this version of $\D_k$ is called $\D_{k,1}'$. 
\item\label{it:A3} Construct the Stallings folding of (each component of) 
$\D_k$.  The result is referred to as $\D_{k,1}$. Whenever two vertices $(u,k)$ and $(v,k)$
of $\D_k$ are identified, by the folding map, to a vertex $(w,k)$ 
set $\vim(w,k)=\vim(u)\cup \vim(v)$. This process will be 
called \textbf{updating} 
$\nu$, from now on.
\item\label{it:A4} (\textbf{Begin Modification 2}.)
 Construct $\cP_k=\D_k\times \G_{A_k}$. 
\item\label{it:A5} Construct a spanning forest $\U_k$ of $\cP_k$ and, simultaneously,
the set $L_{\U_k}$ of words corresponding to paths in $\U_k$ from the root
to each vertex. (A root of $\cP_k$ must  be chosen: 
 to be explicit, assume the root is 
 $((v,k), u)$, where 
$u$ is minimal in some preassigned order on vertices of $\G_{A_k}$ and
$v$ is minimal in some chosen order of vertices of $\D$.)
 We refer to these versions of $\cP_k$ and $\U_k$ as
$\cP_{k,2}$ and $\U_{k,2}$ in the calculation of complexity below. 
\item\label{it:A6} For each vertex $\a$ of $\D_k$ do the following.
 Let 
$\theta(\a)$ be the component of $\cP_k$ containing $(\a,1)$.  
For each vertex $(\b,1)$ of $\theta(\a)$ and for all paths $p$ from 
$(\a,1)$ to $(\b,1)$ add a path from $\a$ to $\b$ to the graph $\D_k$, with
label $\phi_k^{-1}(w)$, where $w$ is the label of $p$. 
This version of $\D_k$ is referred to as $\D_{k,2}'$. 
\item\label{it:A7} Construct the Stallings folding of $\D_k$ and update $\nu$. 
This version of $\D_k$ is referred to as $\D_{k,2}$. 
\item\label{it:A8} (\textbf{Begin Modification 3}.)
 Update $\cP_k=\D_k\times \G_{A_k}$ and $\U_k$, by adding new isolated vertices
if necessary. We refer to these versions of $\cP_k$ and $\U_k$ as
$\cP_{k,3}$ and $\U_{k,3}$.
\item\label{it:A9} For all vertices of $\cP_k$ of the form $(\a,1)$ do the following.
Let $\theta(\a)$ be the component of $\cP_k$ containing $(\a,1)$. 
For each edge $e$ of $\theta(\a)\bs \U_k$: if $e=((\a_i,\b_1),x ,(\a_j,\b_2))$, where $\a_i,\a_j$ are vertices of $\D_k$ and $\b_1,\b_2$ are vertices
of $\G_{A_k}$ and $x\in X_k$, add to $\D_k$ a path from $\a$ to $\a$ with
label $\phi_k^{-1}(l_ixl_j)$, where $l_i$ and $l_j$ are the labels of 
paths in $\U_k$ from $(\a,1)$ to $(\a_i,\b_1)$ and to $(a_j,\b_2)$, 
respectively. This version of $\D_k$ is referred to as $\D_{k,3}'$. 
\item\label{it:A10} Construct the Stallings folding of $\D_k$ and update $\nu$. This version of $\D_k$ is referred to as $\D_{k,3}$. 
\item\label{it:A11} (\textbf{Begin Modification 4}.)
 Update $\cP_k=\D_k\times \G_{A_k}$ and $\U_k$, by adding new isolated vertices
if necessary. We refer to these versions of $\cP_k$ and $\U_k$ as
$\cP_{k,4}$ and $\U_{k,4}$.
\item\label{it:A12} For all vertices of $\cP_k$ of the form $(\a,1)$ do the following.
Let $\theta(\a)$ be the component of $\cP_k$ containing $(\a,1)$. 
For all vertices $(\a_1,\b)$ of $\theta(\a)$, with $\b\neq 1$, let 
$b=w(\b)$, the label of the path from $1$ to $\b$ in $T_k$. If 
$b$ is readable in the automaton $\cP_k$ with start state $(\a,1)$ and 
the final state, after reading $b$, is $(\a_1,\b)$ there is nothing to do,
for this vertex $(\a_1,\b)$. Otherwise, let $a$ be the label of the
path from $(\a,1)$ to $(\a_1,\b)$ in $\U_k$. Add to $\D_k$ a path from
$\a$ to $\a_1$ with label $(\phi_k^{-1}(ab^{-1}))b$. 
This version of $\D_k$ is referred to as $\D_{k,4}'$. 
\item\label{it:A13} Construct the Stallings folding of $\D_k$ and update $\nu$.
This version of $\D_k$ is referred to as $\D_{k,4}$.  
\item\label{it:A14} (\textbf{Begin Modification 5}.)
Reconstruct $\cP_k=\D_k\times \G_{A_k}$, the spanning forest $\U_k$ and 
the set $L_{\U_k}$. We refer to these versions of $\cP_k$ and $\U_k$ as
$\cP_{k,5}$ and $\U_{k,5}$.
\item\label{it:A15} For all $\b\in V(\D_k)$ do the following. For $(\e,\xi)\in P$, 
if both $b_1=w(\e)$ and $b_2=w(\xi)$ are readable in $\D_k$, 
starting from $\b$, and ending at vertices $\a_1$ and $\a_2$, then 
add to $\D_k$ a path from $\a_1$ to $\a_2$ with label
$\phi_k^{-1}(b_1ca_1^{-1})a_1a_2[\phi_k^{-1}(b_2ca_2^{-1})]^{-1}$, where
$(\e_0,\xi_0)$ is the $\sim$ representative of $(\e,\xi)$, $a_1=w(\e_0)$, 
$a_2=w(\xi_0)$ and $c$ is the connecting element of $(\e,\xi)$. 
This version of $\D_k$ is referred to as $\D_{k,4}'$. 
\item\label{it:A16} Construct the Stallings folding of $\D_k$ and update $\nu$. This version of $\D_k$ is referred to as $\D_{k,5}$. 
\item\label{it:A17} (\textbf{Begin Reassembly}.) For each vertex $(u,k)$ of $\D_1\cup \D_2$,
do the following. For each vertex $(v,k')$ of $\D_1\cup \D_2$, not 
equal to $(u,k)$, if 
$\vim((u,k))\cap \vim((v,k'))\neq \emptyset$ then set $\vim((u,k))=\vim((u,k))\cup
\vim((v,k'))$. For each edge $e$ of $\D_1\cup \D_2$, if $e$ has
initial or terminal vertex equal to $(v,k')$ then replace $e$ with
an edge having $(u,k)$ as initial or terminal vertex, instead of $(v,k')$. 
Delete $(v,k')$, once no more such edges exist.  
Continue for as long as possible. The resulting graph is denoted $\D'$. 
\item\label{it:A18}  For each vertex $\a$ of $\D_Z$, if $\a\in \vim(u,k)$,
 for some  
 vertex $(u,k)$ of $\D'$ then replace $\a$ with $(u,k)$. (Note that, as
we have completed step \ref{it:A17}, there is at most one such vertex of
$\D'$.)  
If $\a$ has been replaced by $(u,k)$ then, for every edge $e$ of $\D_Z$,  
 of the form $(\a,\b)$ (or its reverse), replace $e$ with 
 the edge $((u,k), \b)$ (or its reverse). Call the resulting graph $\D_Z'$.  
\item\label{it:A19} Form $\bar \D$ from the union of $\D'$ and $\D_Z'$:
 by identifying vertices of $\D_Z'$ with vertices of  $\D'$
of the same name. 
\item\label{it:A20}  Construct $\D''$, the Stallings folding of $\bar \D$.
\ee
\section{Summary of the Loop}
Here the assumptions are as for Algorithim II.
 
\noindent\textbf{Input.}
\biz
\item A tuple $k_1, \ldots ,k_s$ of elements of $F_1*_{H_1=H_2}F_2$, 
in double coset normal form and the Stallings folding $\G_K$ of this
tuple as a set of words in $F_1*F_2*F(Z)$. 
\eiz
\noindent\textbf{Output.}
\biz
\item An inverse automaton $\Psi$, with alphabet $\Sigma$ and start 
and final state $1$, such that $\pi(L(\Psi))=K$ and $\Psi$ accepts the
double coset normal form of every element of $K$. 
\eiz
\noindent\textbf{Process.}\\
\be
\item Set $n=0$ and $\D_{(0)}=\G_K$. 
\item\label{it:loop2} Input $\D_{(n)}$ to Algorithm II. Call the output $\D_{(n+1)}$. 
\item If the number of $X_1$ and $X_2$ components of $\D_{(n)}$ and 
$\D_{(n+1)}$ are the same, output $\D_{(n+1)}$ and halt. Otherwise,
 add $1$ to $n$ and go to Step \ref{it:loop2}. 
\ee
\end{document}