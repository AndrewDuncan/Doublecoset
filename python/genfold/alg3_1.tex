\documentclass[a4paper,12pt]{article}
\usepackage{amsmath,amsfonts,amsthm,amscd,amssymb,latexsym}%,eufrak}
%%%%%%%%%%%%%
\usepackage{caption}
\usepackage{subcaption}
\usepackage{enumerate,graphicx,psfrag}%,subfigure}%,jchangebar,oldgerm}
\usepackage[mathscr]{eucal}
\usepackage[usenames]{color}
\usepackage{url}
\usepackage[shortlabels]{enumitem}
\usepackage{comment}
%\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
%\usepackage{showkeys}
\usepackage{wrapfig}
\usepackage{lscape}
\usepackage{rotating}
%%%%%%%%%
\sloppy
%%%%%%%%%%%%%%%%%%%%%%%
\title{The subgroup membership problem in amalgamated products of 
finitely generated free groups
}
\author{Andrew J. Duncan, Elizaveta Frenkel}

\renewcommand{\a}{\alpha }
\renewcommand{\b}{\beta }
\newcommand{\G}{\Gamma }
\newcommand{\g}{\gamma }
\newcommand{\D}{\Delta }
\renewcommand{\d}{\delta }
%\def\vd{\vardelta}
\newcommand{\ep}{\epsilon }
\newcommand{\e}{\varepsilon }
\newcommand{\z}{\zeta }
%\eta
\renewcommand{\th}{\theta }
\newcommand{\T}{\Theta }
\renewcommand{\i}{\iota }
\renewcommand{\k}{\kappa }
\renewcommand{\l}{\lambda }
\renewcommand{\L}{\Lambda }
%\mu
%\nu
%\xi
%omicron   
%\pi
\renewcommand{\r}{\rho }
\newcommand{\s}{\sigma }
\renewcommand{\S}{\Sigma }
\renewcommand{\t}{\tau }
\newcommand{\up}{\upsilon }
\newcommand{\U}{\Upsilon }
%\phi
\newcommand{\x}{\chi }
%\psi
\newcommand{\W}{\Omega }
\newcommand{\w}{\omega }
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\pd}{\partial}
\newcommand{\wht}{\widehat}
%\newcommand{\cC}{{\mathcal C}}
%\newcommand{\cdim}{\texttt{cdim}}
\newcommand{\fC}{{\textswab C}}
\newenvironment{ef}{\noindent\color{blue} \bf EF: }{}
%
\newcommand{\cA}{{\cal{A}}}
\newcommand{\cD}{{\cal{D}}}
\newcommand{\cF}{{\cal{F}}}
\newcommand{\cH}{{\cal{H}}}
\newcommand{\cJ}{{\cal{J}}}
\newcommand{\cK}{{\cal{K}}}
\newcommand{\cP}{{\cal{P}}}
\newcommand{\cQ}{{\cal{Q}}}
\newcommand{\cR}{{\cal{R}}}
\newcommand{\cS}{{\cal{S}}}
\newcommand{\cV}{{\cal{V}}}
\newcommand{\cW}{{\cal{W}}}
%\newcommand{\GG}{\ensuremath{\mathbb{G}}}
\newcommand{\pp}{\mathbf{p}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\nul}{\emptyset }
\newcommand{\vim}{\nu\textrm{-im}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{axiom}[theorem]{Axiom}
\newtheorem{definition}[theorem]{Definition}
\newtheorem*{defn*}{Definition}
\newtheorem{conjecture}[theorem]{Conjecture}
%cvs -d :pserver:najd2@cvs.mas.ncl.ac.uk:/CVS/najd2
\newtheorem{exam}[theorem]{Example}
%\newtheorem{comment}[theorem]{Comment}
%
%
\newenvironment{example}{\begin{exam} \rm}{\end{exam}}
%
%
%
\newtheorem{remk}[theorem]{Remark}
\newenvironment{remark}{\begin{remk} \rm}{\end{remk}}
%
%%%%%%%%%%%%
\numberwithin{equation}{section}
\numberwithin{figure}{section}
%%%%%%%%%%%%%%%%%%%%
\newcommand{\Loop}{\operatorname{Loop}}
\newcommand{\Iso}{\operatorname{Isom}}
\newcommand{\Aut}{\operatorname{Aut}}
%%%%%%%%%%%%%%%%%%%
\renewcommand{\AA}{\ensuremath{\mathbb{A}}}
\newcommand{\ZZ}{\ensuremath{\mathbb{Z}}}
\newcommand{\QQ}{\ensuremath{\mathbb{Q}}}
\newcommand{\RR}{\ensuremath{\mathbb{R}}}
\newcommand{\NN}{\ensuremath{\mathbb{N}}}
\newcommand{\CC}{\ensuremath{\mathbb{C}}}
\newcommand{\FF}{\ensuremath{\mathbb{F}}}
%\renewcommand{\ker}{\verb"Ker"}
\newcommand{\cC}{\mathcal{C}}
\renewcommand{\cF}{\mathcal{F}}
\newcommand{\cO}{\mathcal{O}}
\renewcommand{\cS}{\mathcal{S}}
\newcommand{\cT}{\mathcal{T}}
\newcommand{\la}{\langle}
\newcommand{\ra}{\rangle}
%\newcommand{\BA}{\ensuremath{\mathbb{A}}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\maps}{\rightarrow}
\newcommand{\ov}[1]{\overline{#1}}
\newcommand{\bs}{\backslash}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\be}{\begin{enumerate}}
\newcommand{\ee}{\end{enumerate}}
\newcommand{\bd}{\begin{description}}
\newcommand{\ed}{\end{description}}
\newcommand{\biz}{\begin{itemize}}
\newcommand{\eiz}{\end{itemize}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
\newenvironment{ajd1}{\noindent\color{red} AJD }{}
\newcommand{\ajd}[1]{\begin{ajd1} #1 \end{ajd1}}
%
\newenvironment{bl}{\noindent\color{blue} EF }{}
\newcommand{\li}[1]{\begin{bl} #1 \end{bl}}
%\includecomment{comp}% to see environment comp
\excludecomment{comp}% to hide environment comp
%
\begin{document}
\section{Algorithm 3, ``Modification 1''}
Before running this two free groups $F_1$ and $F_2$, on alphabets which we'll call
$X_1$ and $X_2$, must have been entered, as well as a free group on a third alphabet,
$Z$ say, and subgroups $H_i\le F_i$, for $i=1,2$. In addition alg2\_pre must have
been run for each $H_i$, to generate  the foldings $\G_i$, their spanning forests
$T_i$, their doubles, $D_i$ and spanning forests $FD_i$ for $D_i$. 

The input to this part of the algorithm will be a directed rooted 
graph $\D$, with edge labels from $X_1\cup X_2\cup Z$. The output
will be 3 graphs $\D_{1,0}$, $\D_{2,0}$ and $\D_Z$, and 
a set $\vim(u)$, for each vertex of $\D_{1,0}$ and $\D_{2,0}$. That is, for  $k\in \{1,2\}$ carry out the following. We call an edge with a label from $X_k$ an edge of \emph{type} $k$, and an edge with a label from $Z$ an edge
of \emph{type} $Z$. 
\be[{D}1]
\item\label{it:D1} Construct $\D_{k,0}$ and   
a set $\vim(\a)$, for each vertex  $\a$ of $\D_{k,0}$, and build up
the graph $\D_Z$. In detail the steps are
the following. 
\be 
\item\label{it:D1a} Remove all edges of type $X_{k'}$, where $k'=3-k$, from $\D$ to give a graph $\D'_{k,0}$. (Using the appropriate function from  graph.py.)
\item\label{it:D1b} A \emph{shoot} is an edge incident to a leaf. Remove all shoots
of type $Z$ from $\D'_{k,0}$; adding 
edges removed to  a graph $\D_Z$ (which starts off empty, when $k=1$, and  
is not reinitialised when $k$ is incremented to $2$). Continue 
until there are no shoots of type $Z$ in $\D'_{k,0}$.  The resulting graph
is $\D_{k,0}$.  
\item\label{it:D1c}  Rename vertices of $\D_{k,0}$: 
a vertex named $v$  in $\D$ becomes
$(v,k)$ in $\D_{k,0}$. 
\item\label{it:D1d} For each  vertex $(v,k)$  of $\D_{k,0}$,  set 
  $\vim(v,k)$ equal to $\{v\}$. For each vertex $v$ of $\D_Z$, 
set $\vim(v)=\{v\}$. 
\ee
\ee
At the next stage $\D_{k,0}$ is input, and  a graph $\D_{k,1}$ is 
output, $k=1,2$. 
\be[{D}1]
\addtocounter{enumi}{1}
\item\label{it:D2} (\textbf{Begin Modification 1}.)  For all edges
$(\a,z,\b)$ of $\D_{k,0}$, where $z\in Z$, add a path  $(\a,\phi_k(z),\b)$ to
$\D_{k,0}$. The resulting graph is called $\D_{k,1}'$. (The file
graph.py has a function allowing a labelled path to be added to a graph.) 
For each vertex $(v,k)$ in $V(\D_{k,1}')\backslash V(\D_{k,0})$ set  
$\vim(v,k)=\{v\}$. 
\item\label{it:D3}  Construct the Stallings folding $\D_{k,1}$  of (each component of)
$\D_{k,1}'$.  There is more to this than appears at first sight: there
 will often be more than one connected component, so first the bfs
function must be run to find these components. Then each component must
be folded.   
Whenever two  vertices $(u,k)$ and $(v,k)$
of $\D_{k,1}'$ are identified, by the folding map, to a vertex $(w,k)$, 
set $\vim(w,k)=\vim(u,k)\cup \vim(v,k)$.  This process, combined 
with the initialisation, above, of  $\vim$ (to a single vertex) for new vertices
added,  will be 
called \emph{updating} 
$\vim$, in the later stages of algorithm 3. 
\ee
\end{document}