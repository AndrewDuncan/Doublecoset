from alg2 import *
#import sys
import copy

def construct_required_folding(Hname,Hgens,testfile,F,Hrank,verbose):
     
    if verbose==1:
        print("into construct_required_folding")

    #construct the group FZ
    FZ=free_group(int(Hrank),"z")
        
    #set flags for testing subgroup generators
    num_H_gens=1 # set to 0 if Hrank = number of Hgens
    H_gens_in_F=1 # set to 0 if Hgens belong to F
    H_rank=1 # set to 0 if the computed rank of H is equal to Hrank
    H_gens_basis=1 #set to 0 if Hgens coincide with the computed basis for H
    edges_rept=1 #set to 0 if new Hgens are input and do not cause loops in Stallings folding of H
    edges_miss=1 #set to 0 if new Hgens are input and do (possibly) genr H
    nielsen_red=1#set to 0 if Hgens are Nielsen reduced
    

    while num_H_gens==1:
        while True: # a loop that runs till it's broken out of (i.e. until len(Hgens)=Hrank)
            for w in Hgens: #remove trivial elements from Hgens before testing the number of generators
                if w==['']:
                    Hgens.remove(w)
            if len(Hgens)==Hrank: #check if the number of generators equals the required rank of the subgroup
                num_H_gens=0
                break
            else:
                print('Please enter a Nielsen reduced free generating set of size %s ' % (Hrank,),'as a comma separated list, e.g. x1,x2,X1')
                
                if verbose==1:
                    print("calling genr_input")
                Hgens=genr_input(Hrank)

            
            if verbose==1:
                print("after 1st test Hgens is ", Hgens)
                print("Hrank is ", Hrank, "len(Hgens) is ",len(Hgens))

        #if we reach here, then num_H_gens=0
        
        #check that the elements of Hgens are in the free group F
        if verbose==1:
            print("calling generators_in_free_group")
        H_gens_in_F=generators_in_free_group(F,Hgens)# this will be 0 if all elements of Hgens are in F, and 1 otherwise
        if H_gens_in_F!=0: #if some Hgens are not in F, input new Hgens and reset num_H_gens, so no further tests are applied and the loop repeats from the start
            H_gens_in_F=1 #just to make sure
            num_H_gens=1
            print('Please enter a Nielsen reduced free generating set of size %s ' % (Hrank,),'as a comma separated list, e.g. x1,x2,X1, of elements of the free group on generators ', F.gens)
            
            if verbose==1:
                print("calling genr_input")
            Hgens=genr_input(Hrank)

        if verbose==1:
            print("after 2nd test Hgens is ", Hgens)
            print("Hrank is ", Hrank, "len(Hgens) is ",len(Hgens))

        
        if (H_gens_in_F,num_H_gens)==(0,0):#if the tests above were passed ...

            #construct the Stallings folding of H
            if verbose==1:
                print("calling subgroup_compute")
            H=subgroup_compute(Hname,Hgens,FZ)
            
            if len(H.subgroup_free_gens)!=Hrank: #if the rank of the subgroup generated by Hgens is less than the length of Hgens ...
                H_gens_in_F=1 #reset all flags to skip all further tests and return to start of loop
                num_H_gens=1
                #and enter new generators
                print('The basis computed has ', len(H.subgroup_free_gens),' elements, but the required subgroup rank is ',Hrank)
                print('Please enter a Nielsen reduced free generating set of size %s ' % (Hrank,),'as a comma separated list, e.g. x1,x2,X1, of elements of the free group on generators ', F.gens)
                if verbose==1:
                    print("calling genr_input")
                Hgens=genr_input(Hrank)
            else:
                H_rank=0

            
        if (H_gens_in_F,num_H_gens,H_rank)==(0,0,0):#if the tests above were passed ...
            
            #check to see if the generators input are the same as the generators found by Stallings folding
            if verbose==1:
                print("calling check_gens")
            H_gens_basis=check_gens(H,Hgens)
            if H_gens_basis==0: #if H_gens_basis=0 the basis computed is equal to the input generators and the main loop is broken out of
                break

            if verbose==1:
                print("H free gens",H.subgroup_free_gens)
                print("subgroup genrs input", Hgens)

        #this point is reached only if all tests above are passed except the last - in which case it is necessary to find a different spanning tree for the stallings folding of H

       
        stall=label_with_Zs(H,Hgens,verbose) #relabel Stallings folding with given gens/ Z labels - to set up search for required gens
                    
        output_graph_file(stall,"ex_paper/stall_labl.gv","stall",verbose)#for testing only, remove later
                
        #check to see that the new graph is connected and all edges have been used in reading gens
        (edges_miss,edges_rept)=check_nielsen_reduced(stall)



def genr_input(n):

    nn=int(n)
    Hgens=[]
    for i in range(1,nn+1):
        w=input('Enter generator number %s: ' % (i,))
        w=w.replace(' ','')
        w=w.split(",")
        Hgens.append(w)
    return(Hgens)

def generators_in_free_group(F,Hgens):
    
    test=0
    for w in Hgens:
        if not F.is_element(w):
            test=1
            break

    return(test)

def subgroup_compute(Hname,Hgens,FZ):

    H=subgroup(Hname,Hgens,FZ.gens)
    alg2_pre(H)
    return(H)

def check_gens(H,Hgens):  #check to see if the generators Hgens are the ones found by the Stallings folding

    all_clean=0

    for i in range(len(H.subgroup_free_gens)):
        #print("i", i, Hgens[i], "z", H.basis[i])
        #print("free gens",H.subgroup_free_gens[H.basis[i]])
        if  Hgens[i]!=H.subgroup_free_gens[H.basis[i]]:
            all_clean=1
            break
        
    return(all_clean)   

def label_with_Zs(H,Hgens,verbose): 
    if verbose==1:
        print("calling label_with_Zs")
        
    stall=copy.deepcopy(H.flower)#not sure if needed
    
    for u in stall.vertices:
        u.outedges_write ={}# initialise the output labels of the copy of the folding of H
        u.inedges_write = {}
    
    if verbose==1:
        print("len subgp_gens", len(Hgens))
    for i in range(len(Hgens)): # for each of the input generators
        if verbose==1:
            print("i is ", i)
        suffix=Hgens[i]
        u=stall.root
        while len(suffix)>0 and (suffix[0] in u.outedges.keys() or suffix[0].swapcase() in u.inedges.keys()):
            if verbose==1:
                print("suffix", suffix)
            l=suffix[0]
            if l in u.outedges.keys(): # if the current letter is the label of an outedge u
                for x in u.outedgesList: 
                    if l == x[0]: 
                        if (l,x[1]) in u.outedges_write:
                            L=u.outedges_write[(l,x[1])]
                            L.append(H.basis[i])#set the z label of this outedge to the element of the Z-basis for this genr
                            u.outedges_write[(l,x[1])]=L
                        else:
                            u.outedges_write[(l,x[1])]=[H.basis[i]]
                        #now set the write label of the inedge of the vertex at the other end of this edge
                        if (l,u) in x[1].inedges_write:
                            L=x[1].inedges_write[(l,u)]
                            L.append(H.basis[i])#set the z label of this outedge to the  element of the Z-basis for this genr
                            x[1].inedges_write[(l,u)]=L
                        else:
                            x[1].inedges_write[(l,u)]=[H.basis[i]]  
                           
                        if verbose==1:
                            print("read edge ", x, "and set out label to ", H.basis[i])
                        u=x[1] # set u equal to the terminal vertex of the edge read
                        break

            if l.swapcase() in u.inedges.keys():
                for x in u.inedgesList:
                    if l.swapcase() == x[0]: 
                        if (l.swapcase(),x[1]) in u.inedges_write:
                            L=u.inedges_write[(l.swapcase(),x[1])]
                            L.append(H.basis[i].swapcase())#set the z label of this outedge to the inverse of the element of the Z-basis for this genr
                            u.inedges_write[(l.swapcase(),x[1])]=L
                        else:
                            u.inedges_write[(l.swapcase(),x[1])]=[H.basis[i].swapcase()]#set the z label of this inedge to the inverse of the element of the Z-basis for this genr  #the z label of the next edge read
                        #now set the write label of the inedge of the vertex at the other end of this edge
                        if (l.swapcase(),u) in x[1].outedges_write:
                            L=x[1].outedges_write[(l.swapcase(),u)]
                            L.append(H.basis[i].swapcase())#set the z label of this outedge to the element of the Z-basis for this genr
                            x[1].outedges_write[(l.swapcase(),u)]=L
                        else:
                            x[1].outedges_write[(l.swapcase(),u)]=[H.basis[i].swapcase()]
                        if verbose==1:
                            print("read edge ", x, "and set out label to ", H.basis[i])
                        u=x[1] # u is the initial vertex of the edge read (in reverse)
                        break

            suffix = suffix[1:]

    return(stall) 


def output_graph_file(graph,filename,graphname,verbose):  

    if verbose==1:
        print("into output_graph_file")
        print("opening file ",filename)
    with open(filename, "w") as go:
        go.write("digraph graphname {\n") #and write to it
    with open(filename, "a") as go: #then open it in append mode
        go.write(str(graph)) #and continue to write to it
        go.write("}")
    go.close()   
