\documentclass[a4paper,12pt]{article}
\usepackage{amsmath,amsfonts,amsthm,amscd,amssymb,latexsym}%,eufrak}
%%%%%%%%%%%%%
\usepackage{caption}
\usepackage{subcaption}
\usepackage{enumerate,graphicx,psfrag}%,subfigure}%,jchangebar,oldgerm}
\usepackage[mathscr]{eucal}
\usepackage[usenames]{color}
\usepackage{url}
\usepackage[shortlabels]{enumitem}
\usepackage{comment}
%\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
%\usepackage{showkeys}
\usepackage{wrapfig}
\usepackage{lscape}
\usepackage{rotating}
\usepackage{xr}
%\usepackage{underscore}
%%%%%%%%%
\sloppy
%%%%%%%%%%%%%%%%%%%%%%%
\title{The subgroup membership problem in amalgamated products of 
finitely generated free groups
}
\author{Andrew J. Duncan, Elizaveta Frenkel}

\renewcommand{\a}{\alpha }
\renewcommand{\b}{\beta }
\newcommand{\G}{\Gamma }
\newcommand{\g}{\gamma }
\newcommand{\D}{\Delta }
\renewcommand{\d}{\delta }
%\def\vd{\vardelta}
\newcommand{\ep}{\epsilon }
\newcommand{\e}{\varepsilon }
\newcommand{\z}{\zeta }
%\eta
\renewcommand{\th}{\theta }
\newcommand{\T}{\Theta }
\renewcommand{\i}{\iota }
\renewcommand{\k}{\kappa }
\renewcommand{\l}{\lambda }
\renewcommand{\L}{\Lambda }
%\mu
%\nu
%\xi
%omicron
%\pi
\renewcommand{\r}{\rho }
\newcommand{\s}{\sigma }
\renewcommand{\S}{\Sigma }
\renewcommand{\t}{\tau }
\newcommand{\up}{\upsilon }
\newcommand{\U}{\Upsilon }
%\phi
\newcommand{\x}{\chi }
%\psi
\newcommand{\W}{\Omega }
\newcommand{\w}{\omega }
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\pd}{\partial}
\newcommand{\wht}{\widehat}
%\newcommand{\cC}{{\mathcal C}}
%\newcommand{\cdim}{\texttt{cdim}}
\newcommand{\fC}{{\textswab C}}
\newenvironment{ef}{\noindent\color{blue} \bf EF: }{}
%
\newcommand{\cA}{{\cal{A}}}
\newcommand{\cD}{{\cal{D}}}
\newcommand{\cF}{{\cal{F}}}
\newcommand{\cH}{{\cal{H}}}
\newcommand{\cJ}{{\cal{J}}}
\newcommand{\cK}{{\cal{K}}}
\newcommand{\cP}{{\cal{P}}}
\newcommand{\cQ}{{\cal{Q}}}
\newcommand{\cR}{{\cal{R}}}
\newcommand{\cS}{{\cal{S}}}
\newcommand{\cV}{{\cal{V}}}
\newcommand{\cW}{{\cal{W}}}
%\newcommand{\GG}{\ensuremath{\mathbb{G}}}
\newcommand{\pp}{\mathbf{p}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\nul}{\emptyset }
\newcommand{\vim}{\nu\textrm{-im}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{axiom}[theorem]{Axiom}
\newtheorem{definition}[theorem]{Definition}
\newtheorem*{defn*}{Definition}
\newtheorem{conjecture}[theorem]{Conjecture}
%cvs -d :pserver:najd2@cvs.mas.ncl.ac.uk:/CVS/najd2
\newtheorem{exam}[theorem]{Example}
%\newtheorem{comment}[theorem]{Comment}
%
%
\newenvironment{example}{\begin{exam} \rm}{\end{exam}}
%
%
%
\newtheorem{remk}[theorem]{Remark}
\newenvironment{remark}{\begin{remk} \rm}{\end{remk}}
%
%%%%%%%%%%%%
\numberwithin{equation}{section}
\numberwithin{figure}{section}
%%%%%%%%%%%%%%%%%%%%
\newcommand{\Loop}{\operatorname{Loop}}
\newcommand{\Iso}{\operatorname{Isom}}
\newcommand{\Aut}{\operatorname{Aut}}
%%%%%%%%%%%%%%%%%%%
\renewcommand{\AA}{\ensuremath{\mathbb{A}}}
\newcommand{\ZZ}{\ensuremath{\mathbb{Z}}}
\newcommand{\QQ}{\ensuremath{\mathbb{Q}}}
\newcommand{\RR}{\ensuremath{\mathbb{R}}}
\newcommand{\NN}{\ensuremath{\mathbb{N}}}
\newcommand{\CC}{\ensuremath{\mathbb{C}}}
\newcommand{\FF}{\ensuremath{\mathbb{F}}}
%\renewcommand{\ker}{\verb"Ker"}
\newcommand{\cC}{\mathcal{C}}
\renewcommand{\cF}{\mathcal{F}}
\newcommand{\cO}{\mathcal{O}}
\renewcommand{\cS}{\mathcal{S}}
\newcommand{\cT}{\mathcal{T}}
\newcommand{\la}{\langle}
\newcommand{\ra}{\rangle}
%\newcommand{\BA}{\ensuremath{\mathbb{A}}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\maps}{\rightarrow}
\newcommand{\ov}[1]{\overline{#1}}
\newcommand{\bs}{\backslash}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\be}{\begin{enumerate}}
\newcommand{\ee}{\end{enumerate}}
\newcommand{\bd}{\begin{description}}
\newcommand{\ed}{\end{description}}
\newcommand{\biz}{\begin{itemize}}
\newcommand{\eiz}{\end{itemize}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
\newenvironment{ajd1}{\noindent\color{red} AJD }{}
\newcommand{\ajd}[1]{\begin{ajd1} #1 \end{ajd1}}
%
\newenvironment{bl}{\noindent\color{blue} EF }{}
\newcommand{\li}[1]{\begin{bl} #1 \end{bl}}
%\includecomment{comp}% to see environment comp
\excludecomment{comp}% to hide environment comp
%
% EXTERNAL REFERENCES 
%\externaldocument[M-]{membership}
\externaldocument{membership}
\begin{document}
Note to the reader/writer. The same labels (for \texttt{\char`\\}ref statements) as membership.tex work here.
\section{Main problems}
There are some problems with what we wrote before. Some big some small. This is a list of the
ones I know about.
\be
\item The major problem was the halting criterion for the algorithm. The assumption that once the 
number of $X_1$ and $X_2$ components has settled then the algorithm can stop; was false. This can
easily be seen in  action in our examples. 
\item A minor problem was the use of the $\Delta_Z$ component in Algorithm III. The idea was to make 
life easier by removing $Z$-edges that did not induce any modification to the diagram. Although this
could work it would either be necessary change the proof of the fact the alg works, 
or to add $X_1$ and $X_2$ edge paths to follow all such $Z$-edges: that
is for every such edge labelled $z$ there must be paths labelled $\phi_1(z)$ and $\phi_2(z)$ (with the same end points). 
The reason this has to be done is that the proof that the algorithm works starts by assuming that a word accepted
by the folding of $K$ can be rewritten without $Z$ letters; and that the rewritten will still 
be accepted by the automaton output from the 
generalised folding. Without these new paths this will not be true in general. 
Unfortunately I did not see this before. 
Now that I see it has to be done, it seems useless to have a $\Delta_Z$ component - 
after the first pass through the main loop it will be empty in any case. Therefore I have rewritten things
 to leave this out- and it makes everything a bit easier.  
\item Modification 5 still does too much. To get the example we worked on in Moscow to run through a significant number
of iterations of the main loop, I changed the program to leave out Mod 5 altogether. You may (or may not) recall
that we discovered while doing examples, that it was not needed in this particular example. In this example, leaving it
in results in a massive number of unnecessary additions of paths. In general stricter conditions could be applied.  
\ee
\section{Programs}
I have run two examples which I call K\_fix and cex, through the python programs. K\_fix is the one
from the paper - corrected. cex is the one we were working thru in Moscow. There are 2 files that run these examples
K\_fix.py and cex.py. There are comments in the files which are supposed to show how they work. 
\be
\item K\_fix.py. To run this a subdirectory input\_K needs to exist. You can change the number of iterations. It only needs 3 
passes through the main loop, then it stops. However, the flag ``change\_tree'' must be set to 1 to get it to run as we want.
Once this is set (which it is in the file on git) the prog will ask for user inut. The required responses (hit enter after each one) are\\
n\\
y\\
1\\
1\\
3\\

This gets the right gens for $H_1$ and $H_2$. 
\item cex. Here change\_tree = 0 is fine. The max number of iterations is important. Too many and the prog will hang. 
\item Not to forget: mih\_test.py runs the mihailova example. I was able to get this to do 2 iterations before, but only 
when the program was not working correctly. Last time I tried it, it hung on iteration 2. The time before, it spent a week 
working on iteration 4, after which I stopped it before it finished. I need a bigger computer. 
\ee
There are some other things about both these progs which I haven't told you about yet.
To help with testing I have set things up so output can be saved to file and then read back in.
The ``verbose'' list can be used to control this, but some extra directories are needed. 
First a general explanation, then instructions. 
The idea is to generate elements of $K$, by generating balls of radius $R$, in the generators. 
This can be done with a prog called ball\_generate.py. It has instructions for generating 
balls of radius $R$ either of K\_fix or cex. (To make this work directories input\_K/ball or cex/ball must exist.)
Once the ball of radius $R$ has been constructed then the words in it can be fed to the automaton output
from K\_fix or cex. This is done by running ball\_test.py. 

As far as I can see these are working as they should. It takes 2m iterations (or less) to eat up the ball or radius m,
for the cex example. The K\_fix example eats everything I can give it - I made a ball of radius something like 14, which was 
all accepted. 

To see more clearly what is going on in the cex exx words can be processed by step\_through\_normal\_form.py.
This allows you to put in a word (you can find words to put in from the output of ball\_generate) and then 
it describes the steps Algorithm II goes through to put the word in normal form. This is I think what we 
need to understand to see what conditions make the algorithm halt.

Instructions
\be
\item will follow -- now I have run out of steam.
\ee
\section{Changes to the text}

\be
\item Section \ref{sub:reltran} has been changed, twice. The first change was to use
relative transversals, to make normal forms unique. The second change was to remove 
relative transversals, on the realisation that normal forms are unique in any case. The 
new version refers to \emph{right transversals} rather than relative transversals.  
The old version, along
with some examples which perhaps may be useful, is in the file scrap.tex.

\item We have two types of double coset normal form in play.
 There is a double coset normal  form in the free group,
as in section \ref{sub:reltran} and a double coset normal
form for an amalgam, in section \ref{sec:dcnf}. The second
one is the one we really want to call a double coset normal
form, isn't it? It is confusing therefore to call them
both the same thing. 

At the moment, where
I have noticed it, I refer to the free group version as 
the ``free group, double coset normal form''.  (See 
for example Defn  \ref{def:free_dc_nf} %\ref{def:free_dc_nf} 
and the proof of Thm \ref{thm:dcnf}.)
This is too long and needs to be changed, so it's encoded as 
  ``\texttt{\char`\\}normalform''.

We \emph{could} call the free group version 
a $D$-normal form, where $D$ is the set of double coset
representatives. It seems clumsy to me. Do you like it/
dislike it/have a better suggestion? 
\item There are two presentations for the amalgam $F_1*_{H_1=H_2}F_2$, in  \eqref{eq:Xpresn}
and \eqref{eq:Zpresn}. I've called them the $X$-presentation
and $Z$-presentation. \ajd{Maybe don't need this terminology.} We use both, as we sometimes write words in reduced
form w.r.t. the first, and other times in dc-normal form, using the second. 
\item The proof of Theorem \ref{thm:dcnf} has been rewritten, to make
it a little shorter.

\item Algorithm II has been given a label like Algs I and III; see page \pageref{alg:alg2}.
 It has also been amended to cope with words in $\FF(X_1\cup X_2\cup Z)$ and not 
just $\FF(X_1\cup X_2)$. 

\item Preamble to \ref{sec:foldings} changed to accommodate the fact that the main loop may
repeat forever. 

\item Added a couple of sentences to \ref{sec:dca} to cover the case where $K\subseteq H_k$. 
\ajd{This needs to be incorporated into the summary of Alg III and the program.}
\item Trying to keep things simple, the original version of Algorithm III used $\Theta$ to
denote a connected component of $\Delta_k$. However, this does not seem to make much difference
and makes life a bit awkward later on, so now $\Theta_i$ is just used as shorthand for $\Delta_{1,i}$ or $\Delta_{2,i}$.
\item Moved what used to be Lemma 5.3 (lem:dcfold) to the end of Section 3, as it uses all the terminology
defined there, and nothing else. I'm not sure if the statement about the number of  
components is needed any more.
\item The maps that were previously called $\theta_i$ in Section 3 and onwards are now called 
$\theta_{k,i}$ and $\theta_k=\theta_{k,5}\circ\theta_{k,4}\circ\theta_{k,3}\circ\theta_{k,2}\circ\theta_{k,1}$.   
\item Now there is no $\D_z$ the first statement  of Lemma \ref{lem:idverts}, is more or less trivial,
so it is now just a comment at the end of Section \ref{sub:summaryIII}.
\item Proof of Lemma \ref{lem:nfcomp}. The inclusion of the case $s=1$ makes the proof go better.
It reduces the length of the proof of the other 2 cases: in particular Figure ref\{fig:LeR\} is no longer needed. 
The proof of the cases $s\neq 1$ has changed
to accommodate the fact that paths are only added to boundary vertices: the changes are reflectd in Figs \ref{fig:nf-1}
and \ref{fig:nf-2}.
\item The main result so far is now Lemma \ref{lem:nfacc}. 
\ee
\end{document}